Понятие шаблона проектирования, составляющие шаблона. Приведите примеры употребления шаблонов в неверных контекстах
Шаблон проектирования – повторимая архитектурная конструкция, предоставляющая собой решение проблемы проектирования.
Шаблон – не законченный образец, не код, это пример решения задачи, который можно использовать в различных ситуациях.
Идиомы – «низкоуровневые» шаблоны, учитывающие специфику конкретного языка программирования. Они не универсальные. • Архитектурные шаблоны – «наивысший» уровень, охватывают архитектуру всей программной системы.
Алгоритмы – шаблоны вычисления, так как решают вычислительные задачи.
Примеры неверного употребления:
● злоупотребление Singleton. Глобальные переменные не всегда хорошо
● усложнение программы за счет паттернов
● применение паттерна без оснований(Золотой молоток)
● Костыли для слабого языка программирования

Классификация паттернов проектирования, приведите несколько примеров паттернов каждого класса
Виды паттернов проектирования: порождающие (фабрика, строитель, ленивая инициализация, прототип, синглтон),
структурные (адаптер, декоратор, фасад, легковес, мост),
поведенческие (итератор, постредник, стратегия).
Порождающие
Эти паттерны решают проблемы обеспечения гибкости создания объектов
- Структурные
Эти паттерны решают проблемы эффективного построения связей между
объектами
- Поведенческие
Эти паттерны решают проблемы эффективного взаимодействия между
объектами

Функциональные интерфейсы. Понятие функционального интерфейса и использование в программах на языке Джава
Функциональный интерфейс - интерфейс с одним и только одним абстрактным методом (@FunctionalInterface).
Если в каком-то методе функциональный интерфейс передан как параметр, то вместо его реализации можно использовать лямбда-функцию, что заметно упрощает код, делает его более читаемым.
Понятие и использование лямбда -выражений в языке Джава. Примеры
Лямбда функция – блок кода, описывающий функцию интерфейса, некий аналог анонимного класса, только для функциональных интерфейсов.
Lambda-выражения в Java обычно имеют следующий синтаксис
(аргументы) -> (тело). Например:
(арг1, арг2...) -> { тело }
Паттерн “Стратегия. Пример использования функций м для параметризации поведения объектов
Паттерн Стратегия: Функции можно хранить в полях класса и использовать для параметризации поведения объектов (паттерн “Стратегия”)
class Animal { abstract String talk(); }
class Dog extends Animal { String talk() { return “Гав”; }
class Cat extends Animal { String talk() { return “Мяу”; }
Понятие чистой функции. Побочные эффекты функций. Чистота функций в ООП. Пример
Чистая (pure) функция – функция без побочных эффектов, результат которой зависит только от значений ее параметров.
Побочные эффекты функции – то, что делает функция кроме вычисления результата функции. Наиболее частый побочный эффект – изменение состояния объектов (т.е. изменение значений полей). Ввод/вывод также является побочным эффектом.
Часто повторный вызов функции с побочным эффектом производит результат, отличный от предыдущего вызова.

В ООП чистота функций (методов) достигается с помощью использования неизменяемых (immutable) классов.
Неизменяемый класс. Преимущества использования неизменяемых классов. Пример
Все методы неизменяемого класса являются чистыми. После создания объекта неизменяемого класса его состояние больше не меняется. При операциях с такими объектами создаются новые объекты, а не меняются существующие.
Пример: с 16 версии можно прописать так:
public record Point (int x, int y) {}
Не предоставляйте сеттеры или методы, которые изменяют поля или
объекты, ссылающиеся на поля. Сеттеры подразумевают изменение
состояния объекта а это то, чего мы хотим тут избежать.
2. Сделайте все поля final и private. Поля, обозначенные private, будут
недоступными снаружи класса, а обозначение их final гарантирует, что
вы не измените их даже случайно.
3. Не разрешайте субклассам переопределять методы. Самый простой
способ это сделать – объявить класс как final. Финализированные
классы в Java не могут быть переопределены.

Использование неизменяемых полей класса. Преимущества неизменяемых объектов
Для того, чтобы гарантировать неизменяемость свойств объекта, следует использовать модификатор final для полей. Также неизменяемый класс как правило закрыт для наследования, т.к. иначе класс-наследник может добавить изменяемые поля.
Плюсы неизменяемых объектов:
1. Проще понять работу класса: отсутствует “действие на расстоянии”, результат работы программы не зависит от истории, проще проверять инварианты класса
2. Проще тестировать класс
3. Проще использовать в многопоточной среде
4. Можно использовать в качестве ключей Map


Функциональное программирование. Понятие инварианта класса. Примеры
Функциональное программирование - это программирование с
использованием математических функций. Для преобразования методов в
математические функции нам нужно сделать их сигнатуры честными в том
смысле, что они должны полностью отражать все возможные входные данные
и результаты, и нам также необходимо убедиться, что метод работает
только с теми значениями, которые мы передаем, и ничего больше
Инвариант класса – условие, которое должно выполняться на протяжении всего срока жизни объекта.
В случае изменяемого объекта инвариант нужно проверять в каждом методе, изменяющем состояние (mutator method).
Это можно забыть сделать, и инвариант будет нарушен. В неизменяемом классе инвариант достаточно проверять в конструкторе.
Особенности многопоточной работы в Джава, использование final для полей данных для обеспечения потокобезопасности
В языке Java модификатор final для полей имеет особый смысл при многопоточной работе: к полю с этим модификатором могут безопасно обращаться одновременно несколько потоков, и они гарантированно будут видеть одинаковое значение.
Для не-final полей без особой синхронизации потоков может быть так, что каждый поток видит свое значение поля.

MyServer server = new MyServer(80, “http”, Path.of(“web”)); Мы хотим, чтобы эти параметры использовались по умолчанию!
Основное назначение паттерна “Строитель” (Builder) для разработки программ на языке Джава
Паттерн Builder позволяет использовать изменяемый объект для задания свойств, а затем создания на их основе неизменяемого объекта. Как правило изменяемый Builder существует в рамках одного метода и снаружи не виден, так что это не нарушает функциональной чистоты.
Стандартные функциональные интерфейсы в Джава и их методы
1. Function: R apply(T arg) - представляет функцию перехода от объекта
типа T к объекту типа R
2. Supplier: T get() - не принимает никаких аргументов, но должен
возвращать объект типа T
3. Consumer: void accept(T arg) - выполняет некоторое действие над
объектом типа T, при этом ничего не возвращая
4. Predicate: boolean test(T arg) - проверяет соблюдение некоторого
условия. Если оно соблюдается, то возвращается значение true. В качестве
параметра лямбда-выражение принимает объект типа T
Потоки Stream API в Джава и их использование
В интерфейсе Collection объявлен метод stream(), возвращающий поток элементов коллекции.
Поток (Stream) – это представление последовательности элементов, над которым можно производить операции.
 Операции делятся на две категории:
1. Нетерминальные – их результат тоже является потоком, и к нему в свою очередь можно тоже применить операцию;
2. Терминальные – их результат уже не является потоком, и эти операции завершают работу с потоком:
Статический импорт и его использование для программирования Stream API
Директивы статического импорта позволяют использовать статические члены класса без указания имени класса,
т.е. просто joining(“ “) вместо Collectors.joining(“ “).
Статический импорт - синтаксический сахар, т.к. Stream API использует
большое количество статических методов, таких как Stream.of(),
Stream.generate(), Stream.empty(), Stream.generate(), Stream.concate(),
Stream.iterate(), то использование всех этих методов в коде с явным указанием
класса может перегружать читаемость

Назначение метода stream() интерфейса Collection. Примеры
В интерфейсе Collection объявлен метод stream(), возвращающий поток элементов коллекции.
collection.stream().nonTerm1().nonTerm2().term();
Работа со Stream API. Нетерминальные операции потока Stream:, назначение и использование
1. Stream filter(Predicate predicate)
2. Stream map(Function mapper)
3. Stream sorted()
4. Stream distinct()
5. Stream limit(long maxSize)
6. Stream skip(long n)
7. Stream flatMap(Function> mapper)
Каждая нетерминальная операция преобразовывает последовательность элементов, и возвращает поток, соответствующий новой последовательности. Например, метод sorted() сортирует последовательность элементов и возвращает поток уже отсортированных элементов. Метод skip(n) возвращает последовательность без n первых элементов. Самые часто используемые методы – filter и map. Метод filter оставляет в последовательности только те элементы, которые удовлетворяют условию. Метод map применяет функцию к каждому элементу последовательности, получая новую последовательность.
Важная особенность нетерминальных методов – они являются ленивыми, т.е. не создает в памяти новый список из миллиона строк, а создает всего лишь новый объект Stream, который знает, что элементы нужно преобразовывать по мере необходимости.
Работа со Stream API. Терминальные операции, назначение и использование. Примеры
1. R (Collector collector)
2. boolean anyMatch(Predicate predicate)
3. long count()
4. Optional findAny()
5. Optional findFirst()
6. Optional min(Comparator comparator)
7. Optional max(Comparator comparator)
8. T reduce(T identity, BinaryOperator op)
9. void forEach(Consumer action)
Терминальная операция “потребляет” поток, и любые другие вызовы операций на “истраченном” потоке вызовут ошибку
Интерфейс Splititerator и его методы
Класс Stream использует не Iterator а Splititerator
Сплитератор — это интерфейс, который содержит 8 методов, причём четыре из них уже имеют реализацию по умолчанию.
Используется для параллельного программирования, последовательная и параллельная обработка данных. Оставшиеся методы:
1. tryAdvance: полный аналог методов hasNext+next из Iterator; объединены в один, так как так его проще реализовывать
2. Метод estimateSize: может использоваться для оптимизации; например, в нашем MyStream мы могли бы его использовать
для начального размера списка в методе toList
3. Метод trySplit: используется для возможности параллельного обхода коллекции
Понятие многопоточности и написание многопоточных программ на языке Джава
Один процесс может иметь несколько параллельно выполняющихся потоков. В отличие от процессов, все потоки одного процесса
выполняются в одном адресном пространстве, т.е. используют общую память
Потоки используются для:
1. Ускорения работы программы (см. пример с предыдущей лекции: суммирование большого массива данных можно ускорить, если
разбить его на два под-массива и суммировать их в отдельных потоках)
2. Систем массового обслуживания (пример: вебсерверы), когда требуется одновременно выполнять много запросов
Потоки (threads) в Джава. Создание потоков в Джава программах Подходы к созданию потоков: через наследование и реализацию
интерфейса Runnable Thread API. Запуск потока с Runnable
• Наследование от класса Thread: Thread thread = new Thread(); thread.start();
• Реализация интерфейса Runnable: public class MyRunnable implements Runnable { public void run(){ System.out.println("MyRunnable running"); } } или Runnable code = () -> { System.out.println(“Hello Runnable!”); };
Метод start() не может быть вызван более одного раза у одного и того же объекта Thread. Если вы хотите выполнить один и
тот же код в нескольких потоках, создайте для каждого потока свой объект Thread.
Метод t.join() ожидает завершение потока t
По умолчанию программа завершается, когда все ее потоки завершаются. Некоторые потоки можно сделать “демонами” (setDaemon(true)) (т.е. фоновыми процессами), и тогда они не учитываются при определении необходимости завершения программы
Метод Thread.sleep останавливает выполнение текущего потока на указанное количество миллисекунд (1/1000 секунды).
Метод Thread.getState() показывает состояние потока: new – поток создан, но метод start не запущен, runnable – поток запущен, terminated – поток завершен, blocked – поток ждет освобождения от блокировки.
Синхронизация потоков. Понятие синхронизации. Блок синхронизации
Потоки прекрасно работают, если они не используют mutable shared state:
• shared – два или более потока обращаются к одним и тем же данным в памяти
• mutable – данные являются изменяемыми

Блок синхронизации: synchronized (lock)
1. Блок синхронизации для одного и того же lock может выполнять одновременно только один поток
2. Если поток 2 выполняет блок синхронизации с lock после того, как поток 1 выполнил блок синхронизации с lock, то поток 2 “увидит” все изменения, внесенные потоком 1.

Использование синхронизации потоков для пары процессов producer/reader(производители/потребители) + Реализация блока synchronized на основе мониторов
Блок synchronized реализован на основе мониторов:
Монитор может быть в двух состояниях: свободен (released) и захвачен (acquired)
При входе в блок synchronized происходит попытка захвата монитора:
• Если монитор свободен, то он становится захвачен
 • Если монитор уже захвачен другим потоком, то текущий поток останавливается и ждет, пока другой поток не освободит монитор
• Если монитор захвачен текущим потоком, то он остается захвачен
При выходе из блока synchronized монитор освобождается
• Если при этом другие потоки ждали освобождения этого монитора, то выбирается один из этих потоков, который захватывает монитор и входит в свой блок synchronized.

Метод является потокобезопасным (thread-safe), если его можно вызывать из нескольких потоков одновременно.
Потокобезопасность достигается либо с помощью использования неизменяемых объектов, либо с помощью синхронизации

Метод synchronized (lock), особенности его использования для потоков



Синхронизация потоков . Правила happens-before (hb)
Правила happens-before (hb = это отношение между результатом двух событий, так что
если одно событие должно произойти раньше другого, результат должен отражать это, даже
если эти события в действительности выполняются не по порядку):
1. В рамках одного потока любая операция happens-before любой операцией следующей за ней в исходном коде
2. Выход из synhronized блока happens-before входа в synhronized блок на том же мониторе
3. Запись volatile поля happens-before чтение того же самого volatile поля
4. Завершение метода run экземпляра класса Thread happens-before выхода из метода join()
5. Вызов метода start() экземпляра класса Thread happensbefore начало метода run() экземпляра того же треда

Синхронизация потоков. Модификатор полей volatile и его использование
volatile используют, когда нужно:
● обеспечить видимость данных — убедиться, что при обращении к переменной
любой поток получит её последнее записанное значение;
private static volatile boolean ready = false;
Правила happens-before гарантируют, что при чтении volatile поля мы читаем последнее записанное значение.
Упрощенно можно представить, что любое обращение к volatile полю завернуто в блок synchronized.
Но это не гарантирует атомарности операций! “counter++” все равно подвержено проблеме параллельности даже при наличии volatile.
Атомарные операции
Для некоторых случаев удобно использовать классы AtomicInteger counter = new AtomicInteger (0);
Это аналоги volatile полей, но кроме того они добавляют методы, которые выполняются атомарно:
int newValue = counter.addAndGet(delta); // Аналог “counter += delta”
int oldValue = counter.getAndAdd(delta); // Аналог “counter += delta”
int newValue = counter.incrementAndGet(); // Аналог “++counter”
int oldValue = counter.getAndIncrement(); // Аналог “counter++”

Синхронизация потоков. Атомарные операции. Механизм Wait/notify
Атомарная операция — это операция, которая выполняется
полностью или не выполняется совсем, частичное выполнение
невозможно
• Метод lock.wait() освобождает монитор lock и переводит текущий поток в режим ожидания монитора (состояние WAITING). Так как монитор освобожден, другие потоки могут выполнять блоки “synchronized (lock)”, пока этот поток находится в режиме ожидания (“спит”).
• Метод lock.notifyAll() будит все ожидающие этот монитор потоки. Все эти потоки начинают пытаться захватить монитор (это получится не сразу после вызова notifyAll, а только когда вызвавший notifyAll поток выйдет из блока synchronized). После этого все спавшие потоки по очереди захватят монитор и выполнят блок synchronized.
Метод lock.notify(), в отличие от lock.notifyAll(), будит только один поток.
Синхронизация потоков с использованием классов пакета java.util.concurrent.locks
В пакете java.util.concurrent.locks есть классы для расширенной поддержки синхронизации.
Класс ReentrantLock является аналогом блока synchronized с некоторыми дополнительными функциями. В новых версиях Java рекомендуется использовать его вместо synchronized.
Класс ReentrantReadWriteLock позволяет блокировать потоки только в случае, когда идет изменение данных, а в случае чтения данных блокировки потоков не происходит.
Запуск и прерывание потоков. Приостановка и прерывание выполнения нити
Методы interrupt() – для прерывания нити, sleep() для приостановки потока, оборачиваются в конструкцию try-catch. При вызове interrupt() не происходит остановка потока! Это может вызвать нарушение инвариантов.
Что делать, если поток не спит? Необходимо проверить статус прерывания текущего потока
-interrupted() : этот статический метод возвращает true , если текущий поток был прерван, или false в противном случае.
- isInterrupted() : этот нестатический метод проверяет статус прерывания текущего потока и не очищает статус прерывания



Ожидание и присоединение запущенной нити основным потоком управления

Поток сам решает, когда ему можно безопасно остановиться в случае, когда он прерван. Для того, чтобы поток знал, что его прервали, используется два механизма:
1. Некоторые методы ожидания (Thread.sleep, Object.wait) выбрасывают InterruptedException. Оно выбрасывается, если во время ожидания был вызван метод interrupt()
2. Если поток хочет узнать, что метод interrupt() был вызван, он может проверять статус прерывания потока (у каждого потока есть булевское поле, сигнализирующее о том, что поток прерван – interrupted status). Этот статус устанавливается в true, если метод interrupt() был вызван не во время выполнения потоком методов ожидания.
Для присоединения потоков используется метод join. Также необходимо ловить InterruptedExeption.
Жизненный цикл потока Джава

Многопоточные примитивы
• Класс Thread с методами start/join • Блоки synchronized
• Методы wait/notify/notifyAll
• Поля с модификатором volatile
• Классы java.util.concurrent.atomic.*
• Классы java.util.concurrent.locks.*
• Метод interrupt(), InterruptedException и interrupted state
Интерфейс Executor в Джава и его использование. ExecutorService
Интерфейс Executor – абстракция для запуска задач. Он может запускать потоки по необходимости.
Интерфейс java.util.concurrent.Executor — это простой интерфейс для поддержки запуска новых задач
Стандартные реализации интерфейса Executor: Executors.newSingleThreadExecutor()
Executors.newFixedThreadPool(int nThreads)
Executors.newCachedThreadPool()
Все они на самом деле возвращают объект класса ThreadPoolExecutor – реализацию пула потоков. Он состоит из набора потоков и очереди задач. “Под капотом” у него то же класс Thread с методом start и примитивы синхронизации.

ThreadPoolExecutor конфигурируется параметрами:
 • corePoolSize – базовое количество потоков
• maximumPoolSize – максимальное количество потоков
• keepAliveTime – максимальное время простоя потоков
• Тип очереди задач
При выполнении метода executor.execute:
• Если количество потоков в пуле меньше corePoolSize, то для задачи создается новый поток
• Если количество потоков в пуле от corePoolSize до maximumPoolSize, то новый поток создается только тогда, когда очередь заполнена (т.е. в нее нельзя добавить новые задачи)
• Если количество потоков в пуле больше corePoolSize и поток не выполняет задач более чем keepAliveTime, то поток останавливается
Интерфейс Future в Джава. Основное назначение использования его в программах
Future представляет собой будущий результат выполнения задачи:
ExecutorService es = Executors.newFixedThreadPool(10);
Future f1 = es.submit(() -> { Thread.sleep(1000); return “Hello future”; });
Метод isDone() возвращает true, если задача успешно выполнена и ее результат можно получить: String result1 = f1.get();
Если задача становится неактуальной, ее можно отменить: boolean cancelled = f1.cancel(true); // или f1.cancel(false)
Коллекции java.util.concurrent. Состав коллекции. Основные методы

1) ConcurrentCollections, Queues, Synchronizers, Executors, Locs, Atomic
Concurrent Collections — набор коллекций, более эффективно работающие в
многопоточной среде нежели стандартные универсальные коллекции из java.util
пакета. Вместо базового враппера Collections.synchronizedList с блокированием
доступа ко всей коллекции используются блокировки по сегментам данных или же
оптимизируется работа для параллельного чтения данных по wait-free
алгоритмам.
Queues — неблокирующие и блокирующие очереди с поддержкой
многопоточности. Неблокирующие очереди заточены на скорость и работу без
блокирования потоков. Блокирующие очереди используются, когда нужно
«притормозить» потоки «Producer» или «Consumer», если не выполнены
какие-либо условия, например, очередь пуста или перепонена, или же нет
свободного «Consumer»'a.
Synchronizers — вспомогательные утилиты для синхронизации потоков.
Представляют собой мощное оружие в «параллельных» вычислениях.
Executors — содержит в себе отличные фрейморки для создания пулов
потоков, планирования работы асинхронных задач с получением результатов.
Locks — представляет собой альтернативные и более гибкие механизмы
синхронизации потоков по сравнению с базовыми synchronized, wait, notify,
notifyAll.
Atomics — классы с поддержкой атомарных операций над примитивами и
ссылками
Методы: add (добавление элемента в хвост очереди + выбрасывает исключение),
offer(добавление элемента в хвост очереди + ососбое значение), put, poll (удаление элемента из головы + искл) ,
remove (удаление элемента из головы + особое значение), take, element(проверка головы очереди + искл), peek (проверка головы очереди + особое значение)

Потокобезопасные коллекции пакета java.util.concurrent:
Новые интерфейсы: public interface BlockingQueue, и его реализующие:
LinkedBlockingQueue: на основе двусвязного списка, размер может быть неограничен
ArrayBlockingQueue: на основе массива, размер фиксирован SynchronousQueue: очередь “нулевой длины”; добавление элемента в хвост блокируется, пока другой поток не заберет этот элемент из головы

Другие интерфейсы, связанные с очередями:
TransferQueue – блокирующая очередь с подтверждением доставки BlockingDeque – блокирующая двусторонняя очередь Другие классы, связанные с очередями:
ConcurrentLinkedQueue – неблокирующая очередь
ConcurrentLinkedDeque – неблокирующая двусторонняя очередь
DelayQueue – блокирующая очередь с задержкой
LinkedBlockingDeque – блокирующая двусторонняя очередь LinkedTransferQueue – блокирующая очередь с подтверждением доставки PriorityBlockingQueue – блокирующая отсортированная очередь
Кроме очередей, в java.util.concurrent есть и другие потокобезопасные коллекции:
• ConcurrentMap и реализации:
• ConcurrentHashMap – аналог HashMap
• ConcurrentSkipListMap – аналог TreeMap
• ConcurrentSkipListSet – аналог TreeSet
• CopyOnWriteArrayList – аналог ArrayList
Реализация асинхронного выполнения в Джава
Отсюда рождается идея дробить обработку запроса на более мелкие части, чтобы на время ожидания ввода/вывода отдать поток другим ожидающим запросам. Вместо:
String text = readFromFile(); processText(text);
пишем: readFromFile(text -> { processText(text); }); где метод readFromFile, пока файл не будет прочитан, отдает поток другим запросам; processText может быть вызыван уже не в том потоке, что изначальный вызов readFromFile.
В Java это реализовано через CompletableFuture (аналог Promise в JavaScript).
Паттерн “Одиночка” (Singleton) и его использование в Джава программах
Паттерн Singleton гарантирует, что в программе присутствует только один объект данного класса:
public class SomeClass {
public static final SomeClass INSTANCE = new SomeClass();
private SomeClass() { ... }
public void someMethod() { ... }
}
SomeClass.INSTANCE.someMethod();
Использование статических методов для создания экземпляра объекта вместо конструкторов
Преимущества статических фабричных методов (factory methods):
 • говорящее имя, подсказывающее порядок параметров • может кэшировать объекты (пример: Integer.valueOf)
• метод может вернуть подкласс (пример: Collections.emptyList())
Недостатки:
• если создание объектов доступно только через factory method, создание классов-наследников невозможно
Паттерн “Строитель” и его использование большом количестве параметров конструктора
При большом количестве параметров конструктора подумайте о проектном шаблоне Строитель
Понятие dependency injection (внедрение зависимости). Преимущества использования внедрения зависимостей при написании программ на языке Джава. Преимущества этого подхода перед паттерном Одиночка
Минусы этого кода:
• нельзя поменять на другой словарь
• в частности, для тестирования
Другой возможный подход – использование Singleton – имеет те же проблемы:
Dictionary dictionary = Dictionary.getDefaultInstance(); так как может быть использован только один словарь на всю программу.
При развитии программ очень часто оказывается, что некоторая сущность, которая ранее присутствовала в 1 экземпляре, требуется в нескольких экземплярах.
Поэтому использованию Singleton предпочитайте dependency injection.
Паттерн Декоратор (Decorator) Преимущества его использовании (например композиция по сравнению с наследованием)
Наследование может нарушать инкапсуляцию: Решение – использовать композиц ию (паттерн Decorator):
Dependency Injection (внедрение зависимостей) – паттерн композиции классов:
вместо this.service = new BookService();
мы передаем BookService извне в конструкторе:
public BookRest(BookService service) {
this.service = service;
}

Преимущества использования списков перед массивами
Списки более универсальны, чем массивы:
• в списки можно добавлять/удалять значения
• массив можно преобразовать в список через Arrays.asList без копирования данных; при вызове list.toArray данные массива копируются
• пустой список Collections.emptyList() не выделяет память, в отличие от “new Type[0]”
• если нужно запретить изменение списка, можно использовать Collections.unmodifiableList; массив всегда изменяемый
• можно создать “new ArrayList()”, но нельзя “new T[n]”, где T – generic тип
Основные системы сборки Gradle и Maven. Использование Gradle и основная терминология. Управление зависимостями в Gradle
Основные используемые системы сборки – Maven и Gradle. Gradle использует для конфигурации проекта полноценный язык программирования; изначально Groovy, с версии 3.0 также поддерживается Kotlin.
• settings.gradle – из каких (под)проектов состоит сборка. В простейшем случае это один проект, но в большинстве случаев сборка состоит из нескольких (под)проектов

Кроме запуска компиляции, Gradle умеет автоматически скачивать нужные для сборки приложения библиотеки.
Для этого нужно указать:
• репозиторий, из которого качать библиотеки (обычно это mavenCentral: https://repo1.maven.org/maven2)
• “адрес” библиотеки в виде тройки
• group – группа, в которую входит библиотека
• name – имя библиотеки
• version – версия библиотеки
При объявлениях зависимостей в блоке dependencies указываются конфигурации зависимостей (implementation – одна из возможных конфигураций).
Конфигурация зависимостей (dependency configuration) указывает, на что распространяется указанная библиотека. В случае конфигурации implementation библиотека используется при:
• компиляции как основного, так и тестового кода
• выполнении как основного, так и тестового кода
Анатомия jar. Сканирование пакетов
Jar это zip архив специального вида!
• Внутри jar находятся байт код программы, ресурсы а также сохранена переменная classpath для данной программы.
• Напоминание! Classpath это переменная, в которой указаны пути до всех классов программы и самое главное мэин класс.
Реализация REST API с помощью Spring Framework
Внедрение зависимостей — это стиль настройки объекта, при котором поля объекта задаются внешней сущностью
Другими словами, объекты настраиваются внешними объектами. DI — это альтернатива самонастройке объектов.
Задача веб-сервера – выдать данные для отображения в браузере (обычно в формате JSON). Эти данные обрабатываются отдельным frontend приложением:
• в браузере на языке JavaScript
• в мобильном приложении: • Android: Java/Kotlin
• iPhone: ObjectiveC/Swift
REST – стиль взаимодействия клиента с сервером. Обычно он подразумевает запросы и ответы в формате JSON, где адрес запроса содержит информацию о том, что хочет сделать клиент:
• GET /api/books – получить список всех книг
• GET /api/books/11 – получить информацию о книге с id=11
• POST /api/books – создание записи о книге; данные о создаваемой книге передаются в теле запроса
• PUT /api/books/15 – обновление записи о книге с id=15; новые данные о книге передаются в теле запроса

Аннотация @RestController, @GetMapping, @PostMapping
• @GetMapping/@PostMapping/@PutMapping/@DeleteMapping (частные случаи @RequestMapping)
• @RequestParam – описывает параметр, значение которого берется из строки запроса (?name=...)
• @PathVariable – описывает параметр, значение которого берется из пути запроса
• логика работы во многом задается аннотациями

Понятие Инверсии управления
Spring Boot и его использование
Spring Boot – расширение Spring Framework, предоставляющее конфигурации для решения стандартных задач, таких как веб-приложения. Включает в себя: • предустановленный набор библиотек
• встроенный веб-сервер
• средства мониторинга приложения
Работа с базами данных в джава приложениях. Встроенные СУБД для Джава приложений.

Клиент-серверные СУБД (системы управления базами данных):
• PostgreSQL
• Oracle
• MySQL
• Microsoft SQL Server
Встроенные СУБД:
• H2
• Apache Derby
Приложение H2 Console позволяет получить доступ к базе данных с помощью браузера.
Это может быть база данных H2 или другая база данных, поддерживающая JDBC API.
Язык SQL, под-язык Data Manipulation Language (DML): select, insert
Язык SQL, под-язык Data Definition Language (DML): create, drop
Реляционные СУБД для работы с джава приложениями. Пакет java.sql и его классы
Пакет java.sql – классы JDBC (Java Database Connectivity –соединение с БД на Java):
• Connection
• PreparedStatement
• ResultSet
• SQLException
• DriverManager

Роль интерфейса JDBC для работы с джава приложениями
Концепция JDBC – драйверы позволяющих получать соединение с базой данных по специально описанному URL.

Основные компоненты JDBC API
DriverManager:
Это класс, использующийся для управления списком Driver (database drivers).
Driver:
Это интерфейс, использующийся для соединения коммуникации с базой данных, управления коммуникации с базой данных.
Connection:
Интерфейс со всеми методами связи с базой данных. Он описывает коммуникационный контекст. Вся связь с базой данных осуществляется только через объект соединения (connection).
Statement:
Это интерфейс, включающий команду SQL отправленный в базу данных для анализа, обобщения, планирования и выполнения.
ResultSet:
ResultSet представляет набор записей, извлеченных из-за выполнения запроса.

JDBC URL и его использование
JDBC URL – адрес БД, для каждой субд разный.
url = jdbc:postgresql://localhost:5432/db_name

Работа JDBC драйвера
JDBC-драйвер – библиотека для выполнения SQL-запросов для конкретной БД.
JDBC-драйвер подключается через конфигурацию runtimeOnly. Это значит, что его классы недоступны на этапе компиляции.

Как DriverManager понимает, какой класс нужно использовать при обращении к методу getConnection?
Для этого используется интерфейс java.sql.Driver:
public interface Driver {
boolean acceptsURL(String url);
Connection connect(String url, Properties info);
}

В чем заключается роль DI в Spring. Использования ServiceLoader
В простейшем случае Spring DI работает так:
• у Spring Bean (т.е. класса с аннотацией @Component, @Controller/@RestController, @Service, @Repository или @Configuration) есть единственный конструктор
• все параметры этого конструктора тоже являются Spring Beans
• тогда Spring вызывает этот конструктор с нужными Spring beans в качестве параметров
Spring — отличная штука, но бывают случаи, когда ServiceLoader будет правильным выбором.
• Скорость
Для консольных приложений время запуска ServiceLoader НАМНОГО меньше, чем Spring Boot App.
Память
Если вам важно расходование памяти, то следует рассмотреть возможность использования ServiceLoader для DI.
Модули
Java Одним из ключевых аспектов Java-модулей была возможность полностью защитить классы в модуле от кода вне модуля.
Интерфейс Connection. Пулы соединений
Интерфейс Connection описывает активное соединение с БД (в случае клиент-серверной БД – это сетевое соединение).
Пул соединений с базой данных — это набор заранее открытых соединений с базой данных, используемый для предоставления соединения в тот момент, когда оно требуется.
Поэтому используются пулы соединений (по аналогии с пулами потоков). Например, пул с максимальным количеством соединений = 20 позволяет параллельно работать с БД 20 потокам.
При этом соединения не закрываются, а по возможности переиспользуются.
Есть несколько реализаций пулов соединений:
• HikariCP
• Apache Commons DBCP
• C3PO
Принципы SOLID и их использование на Джава
• S – Single Responsibility Principle (Принцип единственной ответственности)
• O – Open/Closed Principle (Принцип открытости/закрытости)
• L – Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
• I – Interface Segregation Principle (Принцип разделения интерфейса).
• D – Dependency Inversion Principle (Принцип инверсии зависимостей)

Принцип единственной ответственности
У класса должна быть только одна обязанность и у него должна быть только одна причина для изменения.
Принцип открытости/закрытости
Принцип открытости/закрытости означает, что классы/интерфейсы должны быть:
• открыты для расширения: означает, что поведение класса может быть расширено путём наследования.
• закрыты для изменения: в результате расширения класса не должны вноситься изменения в код, который использует базовый класс.
Принцип подстановки Барбары Лисков
Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
Принцип разделения интерфейса
Слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические
Принцип инверсии зависимостей
Dependency Injection + использование интерфейсов для связей между уровнями
Преимущество использования try-с-ресурсами по
сравнению с использованием try-finally. Интерфейс интерфейса
AutoCloseable
При завершении работы с потоком его надо закрыть с помощью метода
close(), который определен в интерфейсе Closeable.
При закрытии потока освобождаются все выделенные для него
ресурсы, например, файл. В случае, если поток окажется не закрыт, может
происходить утечка памяти.
Есть два способа закрытия файла. Первый традиционный заключается в
использовании блока try..catch..finally.
Поскольку при открытии или считывании файла может произойти
ошибка ввода-вывода, то код считывания помещается в блок try. И чтобы
быть уверенным, что поток в любом случае закроется, даже если при работе с
ним возникнет ошибка, вызов метода close() помещается в блок finally. И, так
как метод close() также в случае ошибки может генерировать исключение
IOException, то его вызов также помещается во вложенный блок try..catch
Начиная с Java 7 можно использовать еще один способ, который
автоматически вызывает метод close. Этот способ заключается в
использовании конструкции try-with-resources (try-с-ресурсами). Данная
конструкция работает с объектами, которые реализуют интерфейс
AutoCloseable. Так как все классы потоков реализуют интерфейс Closeable,
который в свою очередь наследуется от AutoCloseable, то их также можно
использовать в данной конструкции
Синтаксис конструкции следующий: try(название_класса
имя_переменной = конструктор_класса). Данная конструкция также не
исключает использования блоков catch.
После окончания работы в блоке try у ресурса (в данном случае у
объекта FileInputStream) автоматически вызывается метод close()

Понятие dependency injection (внедрение зависимости).
Преимущества использования внедрения зависимостей при
написании программ на языке Джава. Преимущества этого
подхода перед паттерном Одиночка
Внедрение зависимостей — это стиль настройки объекта, при котором
поля объекта задаются внешней сущностью. Другими словами, объекты
настраиваются внешними объектами. DI — это альтернатива самонастройке
объектов
Главный плюс в том, что мы можем рассматривать приложение, как
набор сервисов или модулей. Сам по себе код получается чуть компактней и
не нужно завязываться на имя класса.
При развитии программ очень часто оказывается, что некоторая
сущность, которая ранее присутствовала в 1 экземпляре, требуется в
нескольких экземплярах.
Поэтому использованию Singleton предпочитайте dependency injection

Понятие Инверсии управления
Инверсия управления - предоставление callback-а в качестве реакции на
какие либо события извне, вместо того, чтобы реализовывать логику
обработки события на месте. Одной из реализаций инверсии управления в применении к управлению зависимостями
                            является внедрение зависимостей


Реализация асинхронного выполнения в Джава
В Java это реализовано через CompletableFuture. Это новый класс для асинхронной работы, который дает возможность
комбинировать шаги обработки, соединяя их в цепочку

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(500);         // имитируем долгое выполнение
    } catch (InterruptedException e) {}
    return "Hi";
});
System.out.println(future.get()); //output H



Spring Boot – расширение Spring Framework, предоставляющее
конфигурации для решения стандартных задач, таких как веб-приложения.
Включает в себя:
• предустановленный набор библиотек
• встроенный веб-сервер
• средства мониторинга приложения
• логика задается аннотациями
Как отмечено выше, Spring — это платформа приложений на основе Java с
открытым кодом, которая охватывает множество небольших проектов. К таким
проектам Spring, помимо прочего, относятся Spring Data, Spring Cloud и Spring
Security. Чтобы понять разницу между Spring Boot и Spring, важно знать, что,
несмотря на различия в основных возможностях, они входят в семейство Spring.
Иными словами, Spring - Платформа веб-приложений с открытым кодом на Java, а
Spring Boot - расширение/модуль, созданный на платформе Spring.
Spring boot Предоставляет возможность создавать автономные приложения Spring, которые
можно запускать сразу же без заметок, конфигурации XML и написания больших объемов
дополнительного кода.
